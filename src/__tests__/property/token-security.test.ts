/**
 * **Feature: luxury-authentication, Property 5: Token security properties**
 * For any authentication token generated by the system, it should be cryptographically 
 * secure, have proper expiration, and be validated correctly
 * **Validates: Requirements 3.2, 4.1**
 */

import { describe, it, expect } from '@jest/globals';
import fc from 'fast-check';
import jwt from 'jsonwebtoken';

const JWT_SECRET = 'test-jwt-secret-key-for-testing-only';

// Test utilities
const validUserIdArbitrary = fc.string({ minLength: 1, maxLength: 50 })
  .filter(s => s.trim().length > 0);

const validEmailArbitrary = fc.string({ minLength: 3, maxLength: 50 })
  .filter(s => s.includes('@') && s.includes('.'))
  .map(s => `test${s.replace(/[^a-zA-Z0-9@.]/g, '')}@example.com`);

describe('Token Security Properties', () => {
  it('should generate tokens with proper JWT structure for any user', () => {
    fc.assert(
      fc.property(validUserIdArbitrary, validEmailArbitrary, (userId, email) => {
        const payload = { userId, email };
        const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });
        
        // Token should be a valid JWT (3 parts separated by dots)
        const parts = token.split('.');
        expect(parts).toHaveLength(3);
        
        // Should be able to decode the token
        const decoded = jwt.verify(token, JWT_SECRET) as any;
        expect(decoded.userId).toBe(userId);
        expect(decoded.email).toBe(email);
        expect(decoded.exp).toBeDefined();
        expect(decoded.iat).toBeDefined();
      }),
      { numRuns: 100 }
    );
  });

  it('should generate tokens with valid expiration times', () => {
    fc.assert(
      fc.property(validUserIdArbitrary, (userId) => {
        const now = Math.floor(Date.now() / 1000);
        const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: '1h' });
        
        const decoded = jwt.verify(token, JWT_SECRET) as any;
        
        // Token should expire in the future
        expect(decoded.exp).toBeGreaterThan(now);
        
        // Token should expire within reasonable time (1 hour + some buffer)
        expect(decoded.exp).toBeLessThan(now + 3700); // 1 hour + 100 seconds buffer
        
        // Token should have been issued recently
        expect(decoded.iat).toBeGreaterThanOrEqual(now - 10); // Allow 10 seconds for test execution
        expect(decoded.iat).toBeLessThanOrEqual(now + 10);
      }),
      { numRuns: 100 }
    );
  });

  it('should validate tokens correctly for any valid token', () => {
    fc.assert(
      fc.property(validUserIdArbitrary, validEmailArbitrary, (userId, email) => {
        const payload = { userId, email };
        const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });
        
        // Valid token should verify successfully
        const decoded = jwt.verify(token, JWT_SECRET) as any;
        expect(decoded.userId).toBe(userId);
        expect(decoded.email).toBe(email);
        
        // Invalid secret should fail
        expect(() => {
          jwt.verify(token, 'wrong-secret');
        }).toThrow();
      }),
      { numRuns: 100 }
    );
  });

  it('should reject invalid or tampered tokens', () => {
    const userId = 'test-user-id';
    const email = 'test@example.com';
    const token = jwt.sign({ userId, email }, JWT_SECRET, { expiresIn: '1h' });
    
    // Tampered token should be rejected
    const tamperedToken = token.slice(0, -5) + 'xxxxx';
    expect(() => {
      jwt.verify(tamperedToken, JWT_SECRET);
    }).toThrow();
    
    // Completely invalid token should be rejected
    expect(() => {
      jwt.verify('invalid.token.here', JWT_SECRET);
    }).toThrow();
    
    // Empty token should be rejected
    expect(() => {
      jwt.verify('', JWT_SECRET);
    }).toThrow();
  });

  it('should handle token expiration correctly', () => {
    const userId = 'test-user-id';
    
    // Create an expired token (negative expiration)
    const expiredToken = jwt.sign({ userId }, JWT_SECRET, { expiresIn: '-1s' });
    
    // Expired token should be rejected
    expect(() => {
      jwt.verify(expiredToken, JWT_SECRET);
    }).toThrow('jwt expired');
  });

  it('should generate unique tokens for each session', () => {
    fc.assert(
      fc.property(validUserIdArbitrary, (userId) => {
        // Generate multiple tokens for the same user
        const token1 = jwt.sign({ userId }, JWT_SECRET, { expiresIn: '1h' });
        const token2 = jwt.sign({ userId }, JWT_SECRET, { expiresIn: '1h' });
        
        // Tokens should be different (due to different iat timestamps)
        expect(token1).not.toBe(token2);
        
        // But both should decode to the same user
        const decoded1 = jwt.verify(token1, JWT_SECRET) as any;
        const decoded2 = jwt.verify(token2, JWT_SECRET) as any;
        
        expect(decoded1.userId).toBe(userId);
        expect(decoded2.userId).toBe(userId);
        expect(decoded1.userId).toBe(decoded2.userId);
      }),
      { numRuns: 50 }
    );
  });
});